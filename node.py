import transaction 
import random, time
import numpy.random as nprandom
from block import Block
import events
from priority_queue import PriorityQueue
class Node:
    def __init__(self, node_id, coins ,hashing_power, is_slow, is_slow_cpu, exp_dist_mean, event_queue, genesis_block, is_attacker):
        # Data members
        self.node_id = node_id
        self.coins = coins
        self.is_slow = is_slow
        self.is_slow_cpu= is_slow_cpu
        self.hashing_power = hashing_power
        self.exp_dist_mean = exp_dist_mean 
        self.running = True
        self.is_attacker = is_attacker # Indicates wheather the node is advesary or not
        self.neighbours = []    #list of nodes neighbours
        self.transaction_queue = []
        self.blocks = {     #dictionary of all blocks node has seen
            0: genesis_block
        }
        self.event_queue = event_queue 
        # self.time_of_block_arrival_list = []
        self.receivedStamps=[]
        self.prev_block_id = 0 
        self.first_block_time_stamp = time.time()
        self.last_block_time_stamp = time.time()
        self.block_queue = PriorityQueue()
        self.forked_blocks = [] 
        self.private_chain = []
        self.prev_private_block_id = 0
        # Set of all the blocks generated by node
        self.generated_blocks = set()
        # Set of all transaction sent so far in order to avode block retransmission 
        self.sent_blocks = set()

        # Create a file for each node with the format "file_node_id.txt"
        self.file_name = f"./node_files/file_{self.node_id}.txt"
        self.avg_interarrival_time = 0 # average interarrival time of all the blocks in received so far.

        # Count of number of block mined by the node
        self.block_mined_count = 0
    
    def __str__(self):
        return f"Node ID: {self.node_id}\nHashing Power: {self.hashing_power}\nIs Slow: {self.is_slow}\nIs slow CPU: {self.is_slow_cpu}\nCoins: {self.coins}\nNeighbours: {self.neighbours}\nAll Nodes: {self.all_nodes}\n"

    # Function to generate transaction
    def generate_transaction(self):

        # Sample a transaction amount and a receiver uniformly at random
        transaction_amount = random.uniform(1, self.coins)  # Adjust the range as needed
        nodelistwithoutme = list(set(self.all_nodes.keys()) - set([self.node_id]))
        receiver_id = random.choice(nodelistwithoutme)  # Adjust the range as needed

        # adding and removing coins from ourselves and the receiver
        self.coins = self.coins - transaction_amount 
        
        # Create the transaction and add it to the transaction queue
        new_transaction = transaction.Transaction(
            transaction_id = str(int(time.time()))+str(self.node_id),
            coins=transaction_amount,
            sender_id=self.node_id,
            receiver_id=receiver_id,
            timestamp = int(time.time())    
        )

        self.transaction_queue.append(new_transaction)

        # Schedule a TxnReceived event at each peer/neighbour, at the current time + network delay
        for neighbour in self.neighbours:
            delay = self.get_latency("transaction", neighbour.is_slow_cpu, neighbour.node_id, 1)
            scheduled_timestamp = time.time() + delay  # Adjust the range as needed
            event = events.TxnReceived(
                event_created_by=self.node_id,
                node=neighbour,
                node_id=neighbour.node_id,
                timestamp=scheduled_timestamp,
                transaction=new_transaction
            )
            self.event_queue.push(event, event.timestamp)  # Add the TxnReceivd event in the event queue

    # Function to receive transaction
    def receive_transaction(self, transaction, event_created_by):
        # Check if the transaction has already been received
        with open('file.txt', 'a') as file:
            file.write("Txn: "+str(transaction.transaction_id)+" recieved by= "+str(self.node_id)+" at time: "+str(time.time())+" \n")

        if transaction.transaction_id not in [txn.transaction_id for txn in self.transaction_queue]:
            # Add the transaction to the received transactions
            self.transaction_queue.append(transaction)
            if transaction.receiver_id==self.node_id:
                # Schedule a TxnReceived event at each neighbour with a randomly sampled delay
                self.coins = self.coins + transaction.coins
            for neighbour in self.neighbours:
                if (neighbour.node_id != event_created_by):
                    delay = self.get_latency("transaction", neighbour.is_slow_cpu, neighbour.node_id, 1)
                    scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                    event = events.TxnReceived(
                        event_created_by=self.node_id,
                        node=neighbour,
                        node_id=neighbour.node_id,
                        timestamp=scheduled_timestamp,
                        transaction=transaction
                    )
                    self.event_queue.push(event, event.timestamp)
    
    # Funaction to generate block
    def generate_block(self):
        self.transaction_queue.sort()
        transactions_in_block = []   
        spent_transaction = self.get_spent_transactions()  
        unspent_transactions = list(set(self.transaction_queue) - spent_transaction)
        for i in range(min(1000, len(unspent_transactions))):
            transactions_in_block.append(unspent_transactions[i])
        prev_longest_chain = self.get_longest_chain()
        mining_time = self.get_mining_time(prev_longest_chain)  

        # Create the coinbase transaction and add it to the transaction queue
        coinbase_transaction = transaction.Transaction(
            transaction_id=str(int(time.time()))+str(self.node_id),
            coins=50,
            sender_id=0,
            receiver_id=self.node_id,
            timestamp = time.time()
        )
        transactions_in_block.insert(0, coinbase_transaction)
        block = Block(
                block_id = str(int(time.time()))+str(self.node_id),
                created_by = self.node_id,
                mining_time = mining_time,
                prev_block_id = self.prev_private_block_id if self.is_attacker else self.prev_block_id,
                transactions = transactions_in_block,
                length_of_chain = len(prev_longest_chain)+1,
                timestamp = time.time()
            )
        
        current_time = time.time()
        if(block.block_id not in self.blocks.keys()):
            event  = events.BlockMined(self.node_id, self, self.node_id, current_time+mining_time, block)
            self.event_queue.push(event, event.timestamp)
        with open(self.file_name, 'a') as file:
            file.write("Block: "+str(block.block_id)+" generated by= "+str(self.node_id)+" at time: "+str(time.time())+".") 
        
    # Function to mine block
    def mined_block(self, block):
        # First get the length of previous longeset chain
        curr_longest_chain = len(self.blocks[self.prev_block_id])
        prev_longest_chain = len(block)-1  # Length of longest chain after mining
        if not self.is_attacker:
            if(curr_longest_chain == prev_longest_chain):
                self.blocks[block.block_id] = block
                self.prev_block_id = block.block_id 
                for neighbour in self.neighbours:
                    delay = self.get_latency("block", neighbour.is_slow_cpu, neighbour.node_id, len(block.transactions))
                    scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                    event = events.BlockReceive(
                        event_created_by=self.node_id,
                        node=neighbour,
                        node_id=neighbour.node_id,
                        timestamp=scheduled_timestamp,
                        block = block
                    )
                    self.event_queue.push(event, event.timestamp)  
                self.sent_blocks.add(block.block_id)
            current_time = time.time()
            event  = events.BlockGenerate(self.node_id, self, self.node_id, current_time)
            self.event_queue.push(event, event.timestamp) 
            self.generated_blocks.add(block.block_id)
            self.block_mined_count += 1
            with open(self.file_name, 'a') as file:
                file.write("Block: "+str(block.block_id)+" mined by= "+str(self.node_id)+" at time: "+str(time.time())+".") 
        else: 
            current_lead = len(self.blocks[self.prev_private_block_id])-len(self.blocks[self.prev_block_id]) # Get the longest chain length
            if(current_lead == 0) and (self.blocks[self.prev_private_block_id].prev_block_id == self.blocks[self.prev_block_id].prev_block_id):
                # Current lead is zero and attacker generates the block before honest miner
                # Then node adds the block in chain and broadcast the generated block
                self.blocks[block.block_id] = block
                self.prev_private_block_id = block.block_id 
                self.private_chain.clear()
                self.prev_block_id = block.block_id # Block id for the top block of the longest chain
                for neighbour in self.neighbours:
                    delay = self.get_latency("block", neighbour.is_slow_cpu, neighbour.node_id, len(block.transactions))
                    scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                    event = events.BlockReceive(
                        event_created_by=self.node_id,
                        node=neighbour,
                        node_id=neighbour.node_id,
                        timestamp=scheduled_timestamp,
                        block = block
                    )
                    self.event_queue.push(event, event.timestamp)  
                self.sent_blocks.add(block.block_id)
                self.block_mined_count += 1
            else:
                self.blocks[block.block_id] = block
                self.prev_private_block_id = block.block_id 
                self.private_chain.append(block)
                self.block_mined_count += 1
            
            # Start generating new block on the longest chain/ private chain depending upon the condition
            current_time = time.time()
            event  = events.BlockGenerate(self.node_id, self, self.node_id, current_time)
            self.event_queue.push(event, event.timestamp) 
            self.generated_blocks.add(block.block_id)
    # Function to receive block from neighbouring peers
    def receive_block(self, block, event_created_by):
        with open(self.file_name, 'a') as file:
            file.write("Block: "+str(block.block_id)+" recieved by= "+str(self.node_id)+" at time: "+str(time.time())+" block_queue_size \n") 
        
        if(self.prev_block_id == 0):
            # The chain is empty now the received block is first block to get added into the blockchain
            self.first_block_time_stamp = time.time() # Record the time at which first block is received
        self.last_block_time_stamp = time.time() # Record the time at which last block is received 
        
        self.block_queue.push(block, block.timestamp)
        prev_chain_len = len(self.blocks[self.prev_block_id])  # Chain length before adding block
        prev_lead = len(self.blocks[self.prev_block_id]) - len(self.blocks[self.prev_private_block_id])
        outstanding_block_list = []
        while not self.block_queue.is_empty(): #and self.block_queue.peek().prev_block_id in self.blocks.keys():
            # The block at the top of queue will get added to chain
            top_block = self.block_queue.pop()
            # Check if the top_block is valid or not 
            if not self.is_valid(top_block):
                continue

            if(top_block.block_id in self.blocks.keys() or  top_block.created_by == self.node_id): 
                continue

            if(top_block.prev_block_id == self.prev_block_id ):
                # This means that the block will simply extend the current blockchain
                self.blocks[top_block.block_id] = top_block
                self.prev_block_id = top_block.block_id
            elif top_block.prev_block_id in self.blocks.keys():
                # This means that there is fork in the blokchain 
                self.blocks[top_block.block_id] = top_block # First add block into the chain
                top_block_len = len(top_block) # Length of chain containing top_block (Forked chain)
                prev_block_len = len(self.blocks[self.prev_block_id]) # Length of chain where the node is pointing
                if(top_block_len == prev_block_len):
                    pass
                elif(top_block_len < prev_block_len):
                    # Orphan the chain containing top_block 
                    pass
                elif(top_block_len > prev_block_len):
                    # Orphan the chain containing prev_block
                    self.prev_block_id = top_block.block_id 
            else:
                outstanding_block_list.append(top_block)
        for b in outstanding_block_list:
            self.block_queue.push(b, b.timestamp)
        curr_chain_len = len(self.blocks[self.prev_block_id]) # Chain length after adding the block
        # Wait for the 6 confirmations before addign the mining reward to current coins
        if(curr_chain_len > prev_chain_len and curr_chain_len > 7):
            curr_block_id = self.prev_block_id
            for i in range(6):
                if curr_block_id == -1:
                    break
                curr_block_id = self.blocks[curr_block_id].prev_block_id
            if self.blocks[curr_block_id].created_by == self.node_id:
                self.coins += 50
        if self.is_attacker:
            lvc_length = len(self.blocks[self.prev_block_id])
            private_chain_length = len(self.blocks[self.prev_private_block_id])
            # If the lead is greater than 2 and we recieved a block then release one block from the private chain
            if(lvc_length - private_chain_length >= 2) and len(self.private_chain) > 0:
                block_to_release = self.private_chain.pop(0)
                self.sent_blocks.add(block_to_release.block_id)
                for neighbour in self.neighbours:
                    if(neighbour.node_id != event_created_by and neighbour.node_id != block_to_release.created_by):
                        delay = self.get_latency("block", neighbour.is_slow_cpu, neighbour.node_id, len(block_to_release.transactions))
                        scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                        event = events.BlockReceive(
                            event_created_by=self.node_id,
                            node=neighbour,
                            node_id=neighbour.node_id,
                            timestamp=scheduled_timestamp,
                            block = block_to_release
                        )
                        self.event_queue.push(event, event.timestamp)
            elif (lvc_length - private_chain_length == 1):
                # If the lead is 2 and attacker received a block then attacker immediately releases all the blocks in private chain
                while len(self.private_chain) > 0:
                    block_to_release = self.private_chain.pop(0)
                    self.sent_blocks.add(block_to_release.block_id)
                    for neighbour in self.neighbours:
                        if(neighbour.node_id != event_created_by and neighbour.node_id != block_to_release.created_by):
                            delay = self.get_latency("block", neighbour.is_slow_cpu, neighbour.node_id, len(block_to_release.transactions))
                            scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                            event = events.BlockReceive(
                                event_created_by=self.node_id,
                                node=neighbour,
                                node_id=neighbour.node_id,
                                timestamp=scheduled_timestamp,
                                block = block_to_release
                            )
                            self.event_queue.push(event, event.timestamp)
                self.prev_block_id = self.prev_private_block_id
            elif (lvc_length - private_chain_length == 0) and len(self.private_chain) > 0:
                block_to_release = self.private_chain.pop(0)
                self.sent_blocks.add(block_to_release.block_id)
                for neighbour in self.neighbours:
                    if(neighbour.node_id != event_created_by and neighbour.node_id != block_to_release.created_by):
                        delay = self.get_latency("block", neighbour.is_slow_cpu, neighbour.node_id, len(block_to_release.transactions))
                        scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                        event = events.BlockReceive(
                            event_created_by=self.node_id,
                            node=neighbour,
                            node_id=neighbour.node_id,
                            timestamp=scheduled_timestamp,
                            block = block_to_release
                        )
                        self.event_queue.push(event, event.timestamp)
            elif (lvc_length - private_chain_length == -1):
                # If current lead is 0 and received a block then start new attack on the received block
                self.prev_private_block_id = self.prev_block_id
                self.private_chain.clear


        # Now broadcast the received block to neighbours
        if (not self.is_attacker) and (block.block_id not in self.sent_blocks):
            self.sent_blocks.add(block.block_id)
            for neighbour in self.neighbours:
                if(neighbour.node_id != event_created_by and neighbour.node_id != block.created_by):
                    delay = self.get_latency("block", neighbour.is_slow_cpu, neighbour.node_id, len(block.transactions))
                    scheduled_timestamp = time.time() + delay  # Adjust the range as needed
                    event = events.BlockReceive(
                        event_created_by=self.node_id,
                        node=neighbour,
                        node_id=neighbour.node_id,
                        timestamp=scheduled_timestamp,
                        block = block
                    )
                    self.event_queue.push(event, event.timestamp) 
            
    # Function to get details about spent transactions
    def get_spent_transactions(self):
        curr_node = self.prev_block_id
        spent_transaction = set() # To store the number of spent transactions
        count = 0 
        while curr_node != 0:
            count += 1
            spent_transaction.update(self.blocks[curr_node].transactions)
            curr_node = self.blocks[curr_node].prev_block_id 
        return spent_transaction

    # Function to determine mining time based on the number of transaction included in the block
    def get_mining_time(self, prev_longest_chain):
        # avg_interarrival_time = (self.last_block_time_stamp - self.first_block_time_stamp)/len(prev_longest_chain)
        # if(avg_interarrival_time == 0):
            # avg_interarrival_time = 1
        avg_interarrival_time = 1
        self.avg_interarrival_time = avg_interarrival_time
        hashing_power = self.hashing_power
        mining_time = nprandom.exponential(avg_interarrival_time/hashing_power)
        return mining_time
    
    # Function to get the length of the longest chain
    def get_longest_chain(self):
        block_chain = []
        # Start with the genesis block
        longest_block = self.blocks[0]

        # Find the block ending with the longest chain
        for block in self.blocks.values():
            # Use block length and creation time to break ties in case of equal length
            if len(block) > len(longest_block) or (
            len(block) == len(longest_block) and block.timestamp < longest_block.timestamp):
                longest_block = block

        # Now find all the blocks in this chain
        current_block = longest_block
        # Do-While Loop!
        while True:
            block_chain.append(current_block)
            # Chain ends at Genesis block which has id 0
            if current_block.block_id == 0:
                break
            # Move backwards
            current_block = self.blocks[current_block.prev_block_id]
        return block_chain

    # Method to set the neighbours of current node
    def add_neighbours(self, neighbours):
        self.neighbours = neighbours 

    # Function to check if block is valid or not
    def is_valid(self, block):
        transaction = block.transactions
        for t in transaction:
            if t.coins < 0:
                return False
        return True
    
    # Method to save all node_ids in the blockchain network into the current node
    def add_allNodes(self, all_nodes):
        self.all_nodes = all_nodes
    
    # Method to get message latency
    def get_latency(self, message_type, is_receiver_slow, neighbour_id, num_of_transaction):
        latency = 0
        message_size = 0
        if(message_type == 'transaction'):
            message_size += 8*10**3
        elif(message_type == 'block'):
            message_size += 8*10**3*num_of_transaction # The message size will depen of the number of transaction included in the block
        
        link_speed = 0
        if not self.is_slow and not is_receiver_slow:
            link_speed = 100*10**8
        else:
            link_speed = 5*10**8
        
        # Transmission delay
        latency += message_size/link_speed

        # Queing delay
        latency += nprandom.exponential(96*1e3/link_speed)

        # Propagation delay
        latency += self.all_nodes[neighbour_id]

        return latency





